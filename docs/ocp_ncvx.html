<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Non-convex path constraints · SCPLib.jl</title><meta name="title" content="Non-convex path constraints · SCPLib.jl"/><meta property="og:title" content="Non-convex path constraints · SCPLib.jl"/><meta property="twitter:title" content="Non-convex path constraints · SCPLib.jl"/><meta name="description" content="Documentation for SCPLib.jl."/><meta property="og:description" content="Documentation for SCPLib.jl."/><meta property="twitter:description" content="Documentation for SCPLib.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="SCPLib.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">SCPLib.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="ocp_basic_cr3bp.html">Basic OCP</a></li><li class="is-active"><a class="tocitem" href="ocp_ncvx.html">Non-convex path constraints</a><ul class="internal"><li><a class="tocitem" href="#Define-dynamics"><span>Define dynamics</span></a></li><li><a class="tocitem" href="#Define-problem"><span>Define problem</span></a></li><li><a class="tocitem" href="#Instantiate-algorithm-and-solve-problem"><span>Instantiate algorithm &amp; solve problem</span></a></li><li><a class="tocitem" href="#Analyze-solution"><span>Analyze solution</span></a></li></ul></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="examples/example_dionysus.html">Dionysus problem</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="api_algorithms.html">API: Algorithms</a></li><li><a class="tocitem" href="api_problems.html">API: Problems &amp; Dynamics</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href="ocp_ncvx.html">Non-convex path constraints</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="ocp_ncvx.html">Non-convex path constraints</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Yuricst/SCPLib.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Yuricst/SCPLib.jl/blob/master/docs/src/ocp_ncvx.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="OCP-with-non-convex-path-constraints"><a class="docs-heading-anchor" href="#OCP-with-non-convex-path-constraints">OCP with non-convex path constraints</a><a id="OCP-with-non-convex-path-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#OCP-with-non-convex-path-constraints" title="Permalink"></a></h1><p>We will now consider an optimal control problem with non-convex path constraints. Here, we will enforce the path constraints at discrete nodes.</p><pre><code class="language-julia hljs">using Clarabel
using ForwardDiff
using GLMakie
using JuMP
using LinearAlgebra
using OrdinaryDiffEq

using SCPLib</code></pre><h2 id="Define-dynamics"><a class="docs-heading-anchor" href="#Define-dynamics">Define dynamics</a><a id="Define-dynamics-1"></a><a class="docs-heading-anchor-permalink" href="#Define-dynamics" title="Permalink"></a></h2><p>We first initialize the dynamics parameters, a control parameter struct, and the equations of motion</p><pre><code class="language-julia hljs"># -------------------- setup problem -------------------- #
# system parameters
nx = 6
nu = 4                              # [ux,uy,uz,Γ]
g = [-9.81, 0, 0]
k_D = 0.5
t_N = 5;                        # s, duration of problem
m = 0.3;                        # kg, mass of quadrotor
T_min = 1.0;                    # N, minimum thrust
T_max = 4.0;                    # N, maximum thrust
theta_max = pi/4;               # rad, maximum tilt angle
N = 50;                         # number of nodes

# initial and final states
x_initial = [0, 0, 0, 0, 0.5, 0];
x_final = [0, 10, 0, 0, 0.5, 0];

# obstacle avoidance parameters
R_obstacle_1 = 1.0              # m, radius of obstacle 1
p_obstacle_1 = [0, 3, 0.45]     # m, position of obstacle 1
R_obstacle_2 = 1.0              # m, radius of obstacle 2
p_obstacle_2 = [0, 7, -0.45]    # m, position of obstacle 2

# ODE parameters
mutable struct QuadroptorParams
    u::Vector
end

params = QuadroptorParams(zeros(nu))

# rhs and jacobian expressions for quadrotor dynamics
function quadrotor_dfdx(x, u, p, t)
    v = x[4:6]
    v_norm = norm(v)
    dfdx = [zeros(3,3) I(3);
            zeros(3,3)  (-k_D * (v_norm * I(3) + (v * v&#39;) / v_norm))]
    return dfdx
end

function quadrotor_dfdu(x, u, p, t)
    dfdu = [zeros(3,4); 1/m * I(3) zeros(3,1)];
    return dfdu
end

function quadrotor_rhs!(dx, x, p, t)
    dx[1:3] = x[4:6]
    dx[4:6] = -k_D*norm(x[4:6])*x[4:6] + g
    B = quadrotor_dfdu(x[1:6], p.u, p, t)
    dx[1:6] += B * p.u
    return
end</code></pre><p>In this tutorial, we will also define the dynamics function for propagating the state-transition matrices:</p><pre><code class="language-julia hljs">function quadroptor_rhs_aug!(dx_aug, x_aug, p, t)
    quadrotor_rhs!(dx_aug, x_aug, p, t)

    # derivatives of Phi_A, Phi_B
    A = quadrotor_dfdx(x_aug[1:6], p.u, p, t)
    B = quadrotor_dfdu(x_aug[1:6], p.u, p, t)
    dx_aug[7:42] = reshape((A * reshape(x_aug[7:42],6,6)&#39;)&#39;, 36)
    dx_aug[nx*(nx+1)+1:nx*(nx+1)+nx*nu] = reshape((A * reshape(x_aug[nx*(nx+1)+1:nx*(nx+1)+nx*nu], (nu,nx))&#39; + B)&#39;, nx*nu)
end</code></pre><h2 id="Define-problem"><a class="docs-heading-anchor" href="#Define-problem">Define problem</a><a id="Define-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Define-problem" title="Permalink"></a></h2><p>We can define the objective function</p><pre><code class="language-julia hljs">function objective(x, u)
    return sum(u[4,:])
end</code></pre><p>We will now define the non-convex path constraints</p><pre><code class="language-julia hljs">nh = 2 * N    # two obstacles, enforced at each node
function h_noncvx(x,u)
    h = vcat(
        [R_obstacle_1 - norm(x[1:3,k] - p_obstacle_1) for k in 1:N],
        [R_obstacle_2 - norm(x[1:3,k] - p_obstacle_2) for k in 1:N]
    )
    return h
end</code></pre><p>We will define an initial guess, then construct a problem struct</p><pre><code class="language-julia hljs"># -------------------- create problem -------------------- #
times = LinRange(0.0, t_N, N)

x_ref = hcat([[el for el in LinRange(x_initial[i], x_final[i], N)] for i in 1:6]...)&#39;
u_ref = zeros(nu, N-1)
u_ref[1:3,:] = repeat(-m*g, outer=[1,N-1])
u_ref[4,:] = norm.(eachcol(u_ref[1:3,:]))

# instantiate problem object    
prob = SCPLib.ContinuousProblem(
    Clarabel.Optimizer,
    quadrotor_rhs!,
    params,
    objective,
    times,
    x_ref,
    u_ref;
    nh = nh,
    h_noncvx = h_noncvx,
    eom_aug! = quadroptor_rhs_aug!,   # uncomment to use the user-defined eom_aug!
    ode_method = Tsit5(),
)
set_silent(prob.model)</code></pre><p>and we will append convex constraints to <code>prob.model</code></p><pre><code class="language-julia hljs"># append boundary conditions
@constraint(prob.model, constraint_initial_rv, prob.model[:x][:,1] == x_initial)
@constraint(prob.model, constraint_final_rv,   prob.model[:x][:,end] == x_final)
@constraint(prob.model, constraint_initial_u, prob.model[:u][1:3,1] == -m * g)
@constraint(prob.model, constraint_final_u, prob.model[:u][1:3,end] == -m * g)

# append convex path constraints
@constraint(prob.model, constraint_x, prob.model[:x][1,:] == 0)

# append constraints on control magnitude
@constraint(prob.model, constraint_associate_control[k in 1:N-1],
    [prob.model[:u][4,k], prob.model[:u][1:3,k]...] in SecondOrderCone())
@constraint(prob.model, constraint_control_magnitude_min[k in 1:N-1],
    prob.model[:u][4,k] &gt;= T_min)
@constraint(prob.model, constraint_control_magnitude_max[k in 1:N-1],
    prob.model[:u][4,k] &lt;= T_max)</code></pre><h2 id="Instantiate-algorithm-and-solve-problem"><a class="docs-heading-anchor" href="#Instantiate-algorithm-and-solve-problem">Instantiate algorithm &amp; solve problem</a><a id="Instantiate-algorithm-and-solve-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Instantiate-algorithm-and-solve-problem" title="Permalink"></a></h2><p>We can now instantiate an algorithm and solve</p><pre><code class="language-julia hljs">algo = SCPLib.SCvxStar(nx, N; nh=nh, w0 = 10.0, l1_penalty=true)

# solve problem
tol_feas = 1e-8
tol_opt = 1e-6
solution = SCPLib.solve!(algo, prob, x_ref, u_ref; tol_opt = tol_opt, tol_feas = tol_feas)</code></pre><pre><code class="nohighlight hljs"> Solving OCP with SCvx* Algorithm (`・ω・´)

   Feasibility tolerance tol_feas :  1.00e-08
   Optimality tolerance tol_opt   :  1.00e-06
   Objective tolerance tol_J0     : -1.00e+16
   Initial penalty weight w       :  1.00e+01
   Use L1 penalty                 :  Yes

Iter |     J0     |    ΔJ_i    |    ΔL_i    |     χ_i    |    ρ_i    |    r_i    |     w     |  acpt. |
   1 |  1.442e+02 |  9.588e+00 |  8.705e+00 |  4.969e-01 |  1.10e+00 |  5.00e-02 |  1.00e+01 |  yes   |
   2 |  1.445e+02 |  3.493e+01 |  3.370e+01 |  3.488e-01 |  1.04e+00 |  1.50e-01 |  2.00e+01 |  yes   |
   3 |  1.460e+02 |  3.967e+01 |  4.452e+01 |  1.945e-01 |  8.91e-01 |  4.50e-01 |  2.00e+01 |  yes   |
   4 |  1.490e+02 |  1.945e+01 |  3.340e+01 |  8.067e-02 |  5.82e-01 |  1.35e+00 |  2.00e+01 |  yes   |
   5 |  1.509e+02 |  1.205e+01 |  1.207e+01 |  2.637e-04 |  9.98e-01 |  1.35e+00 |  2.00e+01 |  yes   |
   6 |  1.509e+02 |  1.969e-02 |  1.969e-02 |  6.529e-09 |  1.00e+00 |  4.05e+00 |  2.00e+01 |  yes   |
   7 |  1.509e+02 |  6.677e-07 |  6.255e-07 |  1.631e-10 |  1.07e+00 |  1.22e+01 |  4.00e+01 |  yes   |

   Status                   : Optimal
   Iterations               : 7
   Total CPU time           : 1.70 sec
   Objective                : 1.5088e+02
   Objective improvement ΔJ : 6.6765e-07 (tol: 1.0000e-06)
   Max constraint violation : 1.6306e-10 (tol: 1.0000e-08)</code></pre><h2 id="Analyze-solution"><a class="docs-heading-anchor" href="#Analyze-solution">Analyze solution</a><a id="Analyze-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Analyze-solution" title="Permalink"></a></h2><p>We can now visualize the solution</p><pre><code class="language-julia hljs"># propagate solution
sols_opt, g_dynamics_opt = SCPLib.get_trajectory(prob, solution.x, solution.u)

# get obstacles x[2] &amp; x[3] values for plotting
coord_obstacle_1 = R_obstacle_1 * [cos.(LinRange(0, 2*pi, 100)) sin.(LinRange(0, 2*pi, 100))]&#39; .+ p_obstacle_1[2:3]
coord_obstacle_2 = R_obstacle_2 * [cos.(LinRange(0, 2*pi, 100)) sin.(LinRange(0, 2*pi, 100))]&#39; .+ p_obstacle_2[2:3]

# plot
fig = Figure(size=(1200,800))
ax2d = Axis(fig[1,1]; xlabel = &quot;East, m&quot;, ylabel = &quot;North, m&quot;, autolimitaspect=1)
scatter!(ax2d, [x_initial[2]], [x_initial[3]], color=:blue)
scatter!(ax2d, [x_final[2]], [x_final[3]], color=:green)
for (i, _sol) in enumerate(sols_opt)
    lines!(ax2d, Array(_sol)[2,:], Array(_sol)[3,:], color=:black)
end
lines!(ax2d, coord_obstacle_1[1,:], coord_obstacle_1[2,:], color=:red)
lines!(ax2d, coord_obstacle_2[1,:], coord_obstacle_2[2,:], color=:red)

# plot controls
ax_u = Axis(fig[2,1]; xlabel=&quot;Time&quot;, ylabel=&quot;Control&quot;)
for i in 1:3
    stairs!(ax_u, prob.times[1:end-1], solution.u[i,:], label=&quot;u[$i]&quot;, step=:pre, linewidth=1.0)
end
stairs!(ax_u, prob.times[1:end-1], solution.u[4,:], label=&quot;||u||&quot;, step=:pre, linewidth=2.0, color=:black, linestyle=:dash)
hlines!(ax_u, [-T_max, T_max], color=:red, linestyle=:dot, label=&quot;||u|| bounds&quot;)
axislegend(ax_u, position=:cc)

# plot iterate information
colors_accept = [solution.info[:accept][i] ? :green : :red for i in 1:length(solution.info[:accept])] 
ax_χ = Axis(fig[1,2]; xlabel=&quot;Iteration&quot;, ylabel=&quot;χ&quot;, yscale=log10)
scatterlines!(ax_χ, 1:length(solution.info[:accept]), solution.info[:χ], color=colors_accept, marker=:circle, markersize=7)

ax_w = Axis(fig[2,2]; xlabel=&quot;Iteration&quot;, ylabel=&quot;w&quot;, yscale=log10)
scatterlines!(ax_w, 1:length(solution.info[:accept]), solution.info[:w], color=colors_accept, marker=:circle, markersize=7)

ax_J = Axis(fig[1,3]; xlabel=&quot;Iteration&quot;, ylabel=&quot;ΔJ&quot;, yscale=log10)
scatterlines!(ax_J, 1:length(solution.info[:accept]), abs.(solution.info[:ΔJ]), color=colors_accept, marker=:circle, markersize=7)

ax_Δ = Axis(fig[2,3]; xlabel=&quot;Iteration&quot;, ylabel=&quot;trust region radius&quot;, yscale=log10)
scatterlines!(ax_Δ, 1:length(solution.info[:accept]), [minimum(val) for val in solution.info[:Δ]], color=colors_accept, marker=:circle, markersize=7)

display(fig)</code></pre><p><img src="assets/quadcoptor_traj_scvxstar.png" alt="SCvxStar quadcoptor trajectory solution"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="ocp_basic_cr3bp.html">« Basic OCP</a><a class="docs-footer-nextpage" href="examples/example_dionysus.html">Dionysus problem »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 14 February 2026 23:36">Saturday 14 February 2026</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
