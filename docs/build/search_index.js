var documenterSearchIndex = {"docs":
[{"location":"api.html#Core-routines","page":"API","title":"Core routines","text":"","category":"section"},{"location":"api.html#Continuous-and-Impulsive-Problems","page":"API","title":"Continuous and Impulsive Problems","text":"","category":"section"},{"location":"api.html#Equations-of-motion","page":"API","title":"Equations of motion","text":"","category":"section"},{"location":"api.html#Algorithms","page":"API","title":"Algorithms","text":"","category":"section"},{"location":"api.html#Main.SCPLib.get_trajectory_augmented-Tuple{Main.SCPLib.ContinuousProblem, Union{LinearAlgebra.Adjoint, Matrix}, Union{LinearAlgebra.Adjoint, Matrix}}","page":"API","title":"Main.SCPLib.get_trajectory_augmented","text":"Propagate augmented dynamics with continuous control This function also constructs state-transition matrices and  evaluates dynamics residuals.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.SCPLib.init_continuous_dynamics_xaug-Tuple{Vector, Int64, Int64}","page":"API","title":"Main.SCPLib.init_continuous_dynamics_xaug","text":"Initialize augmented state for continuous dynamics\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.SCPLib.ContinuousProblem-Tuple{Any, Function, Any, Function, Any, Any, Any}","page":"API","title":"Main.SCPLib.ContinuousProblem","text":"Construct a continuous optimal control problem\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.SCPLib.get_trajectory_augmented-Tuple{Main.SCPLib.ImpulsiveProblem, Any, Any}","page":"API","title":"Main.SCPLib.get_trajectory_augmented","text":"Propagate augmented dynamics with continuous control This function also constructs state-transition matrices and  evaluates dynamics residuals.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.SCPLib.init_impulsive_dynamics_xaug-Tuple{Real, Vector, Vector, Int64, Function}","page":"API","title":"Main.SCPLib.init_impulsive_dynamics_xaug","text":"Initialize augmented state for continuous dynamics\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.SCPLib.ImpulsiveProblem-Tuple{Any, Function, Any, Function, Any, Any, Any}","page":"API","title":"Main.SCPLib.ImpulsiveProblem","text":"Construct an impulsive optimal control problem\n\nIf set_dynamics_cache! is provided, it will be used to set STM's to prob.lincache.\n\nThe signature of set_dynamics_cache! should be:\n\nset_dynamics_cache!(prob::OptimalControlProblem, x_ref::Union{Matrix,Adjoint}, u_ref::Union{Matrix,Adjoint}, y_ref::Union{Matrix,Nothing})\n\nand the function should return the dynamics residuals.  See set_dynamics_cache! for more details.\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.SCPLib.get_continuous_augmented_eom-Tuple{Function, Any, Int64}","page":"API","title":"Main.SCPLib.get_continuous_augmented_eom","text":"Get augmented in-place dynamics function with signature eom_aug!(dx_aug, x_aug, p, t)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.SCPLib.get_continuous_augmented_eom-Tuple{Function, Function, Function, Int64, Int64}","page":"API","title":"Main.SCPLib.get_continuous_augmented_eom","text":"Get augmented in-place dynamics function with signature eom_aug!(dx_aug, x_aug, p, t)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.SCPLib.get_impulsive_augmented_eom-Tuple{Function, Any, Int64}","page":"API","title":"Main.SCPLib.get_impulsive_augmented_eom","text":"Get augmented in-place dynamics function with signature eom_aug!(dx_aug, x_aug, p, t)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.SCPLib.get_impulsive_augmented_eom-Tuple{Function, Function, Int64}","page":"API","title":"Main.SCPLib.get_impulsive_augmented_eom","text":"Get augmented in-place dynamics function with signature eom_aug!(dx_aug, x_aug, p, t)\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.SCPLib.penalty-Tuple{Main.SCPLib.FixedTRWSCP, Main.SCPLib.OptimalControlProblem, Any, Any, Any}","page":"API","title":"Main.SCPLib.penalty","text":"Augmented Lagrangian penalty function\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.SCPLib.solve!-Tuple{Main.SCPLib.FixedTRWSCP, Main.SCPLib.OptimalControlProblem, Any, Any}","page":"API","title":"Main.SCPLib.solve!","text":"Solve non-convex OCP with fixed trust-region-weight SCP Algorithm\n\nThis algorithm employs a fixed trust-region & accepts every convex subproblem step. Artificial infeasibility is avoided by introducing slack variables for nonlinear constraints that are penalized quadratically with a fixed weight.\n\nArguments\n\nalgo::FixedTRWSCP: algorithm struct\nprob::OptimalControlProblem: problem struct\nx_ref: reference state history, size nx-by-N\nu_ref: reference control history, size nu-by-N-1\nmaxiter::Int: maximum number of iterations\ntol_feas::Float64: feasibility tolerance\ntol_opt::Float64: optimality tolerance\ntol_J0::Real: objective tolerance\nverbosity::Int: verbosity level\nstore_iterates::Bool: whether to store iterates\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.SCPLib.solve!-Tuple{Main.SCPLib.ProxLinear, Main.SCPLib.OptimalControlProblem, Any, Any}","page":"API","title":"Main.SCPLib.solve!","text":"Solve non-convex OCP with prox-linear algorithm\n\nArguments\n\nalgo::ProxLinear: algorithm struct\nprob::OptimalControlProblem: problem struct\nx_ref: reference state history, size nx-by-N\nu_ref: reference control history, size nu-by-N-1\nmaxiter::Int: maximum number of iterations\ntol_feas::Float64: feasibility tolerance\ntol_opt::Float64: optimality tolerance\ntol_J0::Real: objective tolerance\nverbosity::Int: verbosity level\nstore_iterates::Bool: whether to store iterates\ncallback::Union{Nothing,Function}: callback function\nwarmstart_primal::Bool: whether to warmstart primal variables\nwarmstart_dual::Bool: whether to warmstart dual variables\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.SCPLib.ProxLinear","page":"API","title":"Main.SCPLib.ProxLinear","text":"Prox-linear algorithm\n\nThe weights are defined such that the penalized objective of the subproblems are:\n\nL(Z) + w_ep * G(Z) + G(Z_ref)*(Z - Z_ref)_1 + w_prox2 * Z - Z_ref_2^2\n\nwhere L(Z) is the original objective function, G(Z) are the non-convex constraints.\n\nArguments\n\nw_ep::Float64: exact penalty term weight\nw_prox::Float64: proximal term weight\nproximal_u::Bool: whether to enforce proximal constraint on u\n\n\n\n\n\n","category":"type"},{"location":"api.html#Main.SCPLib.ProxLinearSolution","page":"API","title":"Main.SCPLib.ProxLinearSolution","text":"Solution struct for prox-linear algorithm\n\n\n\n\n\n","category":"type"},{"location":"api.html#Main.SCPLib.penalty-Tuple{Main.SCPLib.SCvxStar, Main.SCPLib.OptimalControlProblem, Matrix{Float64}, Any, Any}","page":"API","title":"Main.SCPLib.penalty","text":"Augmented Lagrangian penalty function\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.SCPLib.solve!-Tuple{Main.SCPLib.SCvxStar, Main.SCPLib.OptimalControlProblem, Any, Any}","page":"API","title":"Main.SCPLib.solve!","text":"Solve non-convex OCP with SCvx* algorithm\n\nArguments\n\nalgo::SCvxStar: algorithm struct\nprob::OptimalControlProblem: problem struct\nx_ref: reference state history, size nx-by-N\nu_ref: reference control history, size nu-by-N-1\nmaxiter::Int: maximum number of iterations\ntol_feas::Float64: feasibility tolerance\ntol_opt::Float64: optimality tolerance\ntol_J0::Real: objective tolerance\nJ_expected::Real: expected objective value\nK_w::Real: initial penalty weight scaling factor\nverbosity::Int: verbosity level\nstore_iterates::Bool: whether to store iterates\ncallback::Union{Nothing,Function}: callback function\nwarmstart_primal::Bool: whether to warmstart primal variables\nwarmstart_dual::Bool: whether to warmstart dual variables\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.SCPLib.update_trust_region!-Tuple{Main.SCPLib.SCvxStar, Float64}","page":"API","title":"Main.SCPLib.update_trust_region!","text":"Update trust-region size\n\n\n\n\n\n","category":"method"},{"location":"api.html#Main.SCPLib.SCvxStar","page":"API","title":"Main.SCPLib.SCvxStar","text":"SCvx* algorithm\n\nArguments\n\nnx::Int: number of states\nN::Int: number of time steps\nng::Int: number of non-convex equality constraints\nnh::Int: number of non-convex inequality constraints\nΔ0::Float64: initial trust-region size\nw0::Float64: initial penalty weight\nrhos::Tuple{Real,Real,Real}: trust-region acceptance thresholds\nalphas::Tuple{Real,Real}: trust-region size update factors\nΔ_bounds::Tuple{Float64,Float64}: trust-region size bounds\ngamma::Float64: stationarity tolerance update factor\nbeta::Float64: penalty weight update factor\nw_max::Float64: maximum penalty weight\n\n\n\n\n\n","category":"type"},{"location":"api.html#Main.SCPLib.SCvxStarSolution","page":"API","title":"Main.SCPLib.SCvxStarSolution","text":"Solution struct for SCvx* algorithm\n\n\n\n\n\n","category":"type"},{"location":"index.html#SCPLib.jl:-Sequential-Convex-Programming-library","page":"Home","title":"SCPLib.jl: Sequential Convex Programming library","text":"We are interested in solving the discretized non-convex optimal control problem (OCP)\n\nbeginaligned\nmin_x u quad phi(x(t_f)u(t_f)t_fy) + int_t_0^t_f mathcalL(x(t)u(t)t) mathrmdt\n mathrmst quad     dotx(t) = f(x(t)u(t)t)\n     x_k+1 = x_k + int_t_k^t_k+1 f(x_k u_k) mathrmdt quad forall k=1ldotsN-1\n     g(xu) = 0\n     h(xu) leq 0\n     x_1 in mathcalX(t_1)  x_N in mathcalX(t_N)\n     x_k in mathcalX(t_k) u_k in mathcalU(t_k) quad forall k=1ldotsN\nendaligned\n\nNote:\n\nA free-final time problem can be cast as the above OCP by including physical time as a state & adopting a time dilation.","category":"section"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"For now, git clone the repo & add via pkg> dev ./path/to/SCPLib.jl.","category":"section"},{"location":"index.html#Quick-start","page":"Home","title":"Quick start","text":"We first need to define a few things:\n\na mutable struct parameter for the ODE, which includes a vector u (the control vector),\nthe controlled equations of motion eom!, which takes as parameter the aforementioned mutable struct,\n(optionally) the augmented equations of motion which propagates the state together with the STM's Phi_A and Phi_B,\nan objective function, dispatched for both JuMP variables and reals,\nan array of time-stamps corresponding to the discretized nodes, and\ninitial guesses for state & control histories, x_ref and u_ref; if the problem also has other variables y, then we also need initial guess for those, i.e. y_ref.\n\n# 0. define dynamics, define initial reference (i.e. initial guess), etc.\nnx = 6   # state dimension\nnu = 4   # control dimension\nmutable struct MyODEParams\n    p           # ODE Parameters\n    u::Vector   # control vector, length `nu`\nend\n\nparams = MyODEParams(p, zeros(nu))\n\neom! = function (dx, x, params, t)\n    # compute derivative of state \n    ...\nend\n\neom_aug! = function (dx_aug, x_aug, params, t)              # optional\n    # compute derivative of state & Phi_A & Phi_B\n    ...\nend\n\nobjective = function (x, u)\n    # compute objective, must be dispatched for both JuMP variables and reals \n    ...\nend\n\nN = 60                          # number of nodes\ntimes = LinRange(0.0, tf, N)    # time-stamp at nodes\nx_ref = ...                     # initial guess for state history\nu_ref = ...                     # initial guess for control history\n\nNow we can use SCPLib to construct & solve our optimal control problem!\n\n# 1. instantiate problem    \nprob = SCPLib.ContinuousProblem(\n    Clarabel.Optimizer,                 # solver for convex subproblems\n    eom!,\n    params,\n    objective,\n    times,\n    x_ref,\n    u_ref;\n    eom_aug! = eom_aug!,                # optional\n)\n\n# 2. append convex constraints to `prob.model` if any\n@constraint(prob.model, constraint_initial_rv, prob.model[:x][:,1] == rv0)     # initial boundary conditions\n@constraint(prob.model, constraint_final_rv,   prob.model[:x][:,end] == rvf)   # final boundary conditions\n\nset_silent(prob.model)\n\n# 3. instantiate an algorithm; here we use the SCvx* algorithm\nalgo = SCPLib.SCvxStar(nx, N; w0 = 1e4)   # as an example, setting `w0` to a non-default value\n\n# 4. solve problem\nsolution = SCPLib.solve!(algo, prob, x_ref, u_ref; maxiter = 100)","category":"section"}]
}
