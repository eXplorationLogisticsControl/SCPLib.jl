var documenterSearchIndex = {"docs":
[{"location":"api_problems.html#API:-Problems-and-Dynamics","page":"API: Problems & Dynamics","title":"API: Problems & Dynamics","text":"","category":"section"},{"location":"api_problems.html#Continuous-problems","page":"API: Problems & Dynamics","title":"Continuous problems","text":"","category":"section"},{"location":"api_problems.html#Impulsive-problems","page":"API: Problems & Dynamics","title":"Impulsive problems","text":"","category":"section"},{"location":"api_problems.html#Equations-of-motion","page":"API: Problems & Dynamics","title":"Equations of motion","text":"","category":"section"},{"location":"api_problems.html#Main.SCPLib.get_trajectory_augmented-Tuple{Main.SCPLib.ContinuousProblem, Union{LinearAlgebra.Adjoint, Matrix}, Union{LinearAlgebra.Adjoint, Matrix}}","page":"API: Problems & Dynamics","title":"Main.SCPLib.get_trajectory_augmented","text":"Propagate augmented dynamics with continuous control This function also constructs state-transition matrices and  evaluates dynamics residuals.\n\n\n\n\n\n","category":"method"},{"location":"api_problems.html#Main.SCPLib.init_continuous_dynamics_xaug-Tuple{Vector, Int64, Int64}","page":"API: Problems & Dynamics","title":"Main.SCPLib.init_continuous_dynamics_xaug","text":"Initialize augmented state for continuous dynamics\n\n\n\n\n\n","category":"method"},{"location":"api_problems.html#Main.SCPLib.ContinuousProblem-Tuple{Any, Function, Any, Function, Any, Any, Any}","page":"API: Problems & Dynamics","title":"Main.SCPLib.ContinuousProblem","text":"Construct a continuous optimal control problem\n\n\n\n\n\n","category":"method"},{"location":"api_problems.html#Main.SCPLib.get_trajectory_augmented-Tuple{Main.SCPLib.ImpulsiveProblem, Any, Any}","page":"API: Problems & Dynamics","title":"Main.SCPLib.get_trajectory_augmented","text":"Propagate augmented dynamics with continuous control This function also constructs state-transition matrices and  evaluates dynamics residuals.\n\n\n\n\n\n","category":"method"},{"location":"api_problems.html#Main.SCPLib.init_impulsive_dynamics_xaug-Tuple{Real, Vector, Vector, Int64, Function}","page":"API: Problems & Dynamics","title":"Main.SCPLib.init_impulsive_dynamics_xaug","text":"Initialize augmented state for continuous dynamics\n\n\n\n\n\n","category":"method"},{"location":"api_problems.html#Main.SCPLib.ImpulsiveProblem-Tuple{Any, Function, Any, Function, Any, Any, Any}","page":"API: Problems & Dynamics","title":"Main.SCPLib.ImpulsiveProblem","text":"Construct an impulsive optimal control problem\n\nIf set_dynamics_cache! is provided, it will be used to set STM's to prob.lincache.\n\nThe signature of set_dynamics_cache! should be:\n\nset_dynamics_cache!(prob::OptimalControlProblem, x_ref::Union{Matrix,Adjoint}, u_ref::Union{Matrix,Adjoint}, y_ref::Union{Matrix,Nothing})\n\nand the function should return the dynamics residuals.  See set_dynamics_cache! for more details.\n\n\n\n\n\n","category":"method"},{"location":"api_problems.html#Main.SCPLib.get_continuous_augmented_eom-Tuple{Function, Any, Int64}","page":"API: Problems & Dynamics","title":"Main.SCPLib.get_continuous_augmented_eom","text":"Get augmented in-place dynamics function with signature eom_aug!(dx_aug, x_aug, p, t)\n\n\n\n\n\n","category":"method"},{"location":"api_problems.html#Main.SCPLib.get_continuous_augmented_eom-Tuple{Function, Function, Function, Int64, Int64}","page":"API: Problems & Dynamics","title":"Main.SCPLib.get_continuous_augmented_eom","text":"Get augmented in-place dynamics function with signature eom_aug!(dx_aug, x_aug, p, t)\n\n\n\n\n\n","category":"method"},{"location":"api_problems.html#Main.SCPLib.get_impulsive_augmented_eom-Tuple{Function, Any, Int64}","page":"API: Problems & Dynamics","title":"Main.SCPLib.get_impulsive_augmented_eom","text":"Get augmented in-place dynamics function with signature eom_aug!(dx_aug, x_aug, p, t)\n\n\n\n\n\n","category":"method"},{"location":"api_problems.html#Main.SCPLib.get_impulsive_augmented_eom-Tuple{Function, Function, Int64}","page":"API: Problems & Dynamics","title":"Main.SCPLib.get_impulsive_augmented_eom","text":"Get augmented in-place dynamics function with signature eom_aug!(dx_aug, x_aug, p, t)\n\n\n\n\n\n","category":"method"},{"location":"api_algorithms.html#API:-Algorithms","page":"API: Algorithms","title":"API: Algorithms","text":"","category":"section"},{"location":"api_algorithms.html#SCvx*","page":"API: Algorithms","title":"SCvx*","text":"","category":"section"},{"location":"api_algorithms.html#Prox-linear-method","page":"API: Algorithms","title":"Prox-linear method","text":"","category":"section"},{"location":"api_algorithms.html#Fixed-trust-region/weight","page":"API: Algorithms","title":"Fixed trust-region/weight","text":"","category":"section"},{"location":"api_algorithms.html#Main.SCPLib.penalty-Tuple{Main.SCPLib.SCvxStar, Main.SCPLib.OptimalControlProblem, Matrix{Float64}, Any, Any}","page":"API: Algorithms","title":"Main.SCPLib.penalty","text":"Augmented Lagrangian penalty function\n\n\n\n\n\n","category":"method"},{"location":"api_algorithms.html#Main.SCPLib.solve!-Tuple{Main.SCPLib.SCvxStar, Main.SCPLib.OptimalControlProblem, Any, Any}","page":"API: Algorithms","title":"Main.SCPLib.solve!","text":"Solve non-convex OCP with SCvx* algorithm\n\nArguments\n\nalgo::SCvxStar: algorithm struct\nprob::OptimalControlProblem: problem struct\nx_ref: reference state history, size nx-by-N\nu_ref: reference control history, size nu-by-N-1\nmaxiter::Int: maximum number of iterations\ntol_feas::Float64: feasibility tolerance\ntol_opt::Float64: optimality tolerance\ntol_J0::Real: objective tolerance\nverbosity::Int: verbosity level\nstore_iterates::Bool: whether to store iterates\n\n\n\n\n\n","category":"method"},{"location":"api_algorithms.html#Main.SCPLib.update_trust_region!-Tuple{Main.SCPLib.SCvxStar, Float64}","page":"API: Algorithms","title":"Main.SCPLib.update_trust_region!","text":"Update trust-region size\n\n\n\n\n\n","category":"method"},{"location":"api_algorithms.html#Main.SCPLib.SCvxStar","page":"API: Algorithms","title":"Main.SCPLib.SCvxStar","text":"SCvx* algorithm\n\nArguments\n\nnx::Int: number of states\nN::Int: number of time steps\nng::Int: number of non-convex equality constraints\nnh::Int: number of non-convex inequality constraints\nΔ0::Float64: initial trust-region size\nw0::Float64: initial penalty weight\nrhos::Tuple{Real,Real,Real}: trust-region acceptance thresholds\nalphas::Tuple{Real,Real}: trust-region size update factors\nΔ_bounds::Tuple{Float64,Float64}: trust-region size bounds\ngamma::Float64: stationarity tolerance update factor\nbeta::Float64: penalty weight update factor\nw_max::Float64: maximum penalty weight\n\n\n\n\n\n","category":"type"},{"location":"api_algorithms.html#Main.SCPLib.SCvxStarSolution","page":"API: Algorithms","title":"Main.SCPLib.SCvxStarSolution","text":"Solution struct for SCvx* algorithm\n\n\n\n\n\n","category":"type"},{"location":"api_algorithms.html#Main.SCPLib.solve!-Tuple{Main.SCPLib.ProxLinear, Main.SCPLib.OptimalControlProblem, Any, Any}","page":"API: Algorithms","title":"Main.SCPLib.solve!","text":"Solve non-convex OCP with prox-linear algorithm\n\nArguments\n\nalgo::ProxLinear: algorithm struct\nprob::OptimalControlProblem: problem struct\nx_ref: reference state history, size nx-by-N\nu_ref: reference control history, size nu-by-N-1\nmaxiter::Int: maximum number of iterations\ntol_feas::Float64: feasibility tolerance\ntol_opt::Float64: optimality tolerance\ntol_J0::Real: objective tolerance\nverbosity::Int: verbosity level\nstore_iterates::Bool: whether to store iterates\n\n\n\n\n\n","category":"method"},{"location":"api_algorithms.html#Main.SCPLib.ProxLinear","page":"API: Algorithms","title":"Main.SCPLib.ProxLinear","text":"Prox-linear algorithm\n\nThe weights are defined such that the penalized objective of the subproblems are:\n\nL(Z) + w_ep * G(Z) + G(Z_ref)*(Z - Z_ref)_1 + w_prox2 * Z - Z_ref_2^2\n\nwhere L(Z) is the original objective function, G(Z) are the non-convex constraints.\n\nArguments\n\nw_ep::Float64: exact penalty term weight\nw_prox::Float64: proximal term weight\nproximal_u::Bool: whether to enforce proximal constraint on u\n\n\n\n\n\n","category":"type"},{"location":"api_algorithms.html#Main.SCPLib.ProxLinearSolution","page":"API: Algorithms","title":"Main.SCPLib.ProxLinearSolution","text":"Solution struct for prox-linear algorithm\n\n\n\n\n\n","category":"type"},{"location":"api_algorithms.html#Main.SCPLib.penalty-Tuple{Main.SCPLib.FixedTRWSCP, Main.SCPLib.OptimalControlProblem, Any, Any, Any}","page":"API: Algorithms","title":"Main.SCPLib.penalty","text":"Augmented Lagrangian penalty function\n\n\n\n\n\n","category":"method"},{"location":"api_algorithms.html#Main.SCPLib.solve!-Tuple{Main.SCPLib.FixedTRWSCP, Main.SCPLib.OptimalControlProblem, Any, Any}","page":"API: Algorithms","title":"Main.SCPLib.solve!","text":"Solve non-convex OCP with fixed trust-region-weight SCP Algorithm\n\nThis algorithm employs a fixed trust-region & accepts every convex subproblem step. Artificial infeasibility is avoided by introducing slack variables for nonlinear constraints that are penalized quadratically with a fixed weight.\n\nArguments\n\nalgo::FixedTRWSCP: algorithm struct\nprob::OptimalControlProblem: problem struct\nx_ref: reference state history, size nx-by-N\nu_ref: reference control history, size nu-by-N-1\nmaxiter::Int: maximum number of iterations\ntol_feas::Float64: feasibility tolerance\ntol_opt::Float64: optimality tolerance\ntol_J0::Real: objective tolerance\nverbosity::Int: verbosity level\nstore_iterates::Bool: whether to store iterates\n\n\n\n\n\n","category":"method"},{"location":"ocp_basic_cr3bp.html#Basic-Optimal-Control-Problem","page":"Basic OCP","title":"Basic Optimal Control Problem","text":"We will start with a simple, fixed-time optimal control problem.\n\nusing Clarabel\nusing GLMakie\nusing JuMP\nusing LinearAlgebra\nusing OrdinaryDiffEq\n\nusing SCPLib","category":"section"},{"location":"ocp_basic_cr3bp.html#Define-dynamics","page":"Basic OCP","title":"Define dynamics","text":"We will first define and instantiate a struct that will hold the control, along with any parameters we may want to pass to the equations of motion:\n\n# create parameters with `u` entry\nmutable struct ControlParams\n    μ::Float64\n    u::Vector\n    function ControlParams(μ::Float64)\n        new(μ, zeros(4))\n    end\nend\n\nμ = 1.215058560962404e-02\nDU = 389703     # km\nTU = 382981     # sec\nMU = 500.0      # kg\nVU = DU/TU      # km/s\nparams = ControlParams(μ)\n\nWe will now define an equations of motion\n\nfunction eom!(drv, rv, p, t)\n    x, y, z = rv[1:3]\n    vx, vy, vz = rv[4:6]\n    r1 = sqrt( (x+p.μ)^2 + y^2 + z^2 );\n    r2 = sqrt( (x-1+p.μ)^2 + y^2 + z^2 );\n    drv[1:3] = rv[4:6]\n    # derivatives of velocities\n    drv[4] =  2*vy + x - ((1-p.μ)/r1^3)*(p.μ+x) + (p.μ/r2^3)*(1-p.μ-x);\n    drv[5] = -2*vx + y - ((1-p.μ)/r1^3)*y - (p.μ/r2^3)*y;\n    drv[6] = -((1-p.μ)/r1^3)*z - (p.μ/r2^3)*z;\n    # append controls\n    drv[4:6] += p.u[1:3]\n    return\nend","category":"section"},{"location":"ocp_basic_cr3bp.html#Define-problem","page":"Basic OCP","title":"Define problem","text":"We will now define boundary conditions\n\nrv0 = [1.0809931218390707E+00,\n    0.0000000000000000E+00,\n    -2.0235953267405354E-01,\n    1.0157158264396639E-14,\n    -1.9895001215078018E-01,\n    7.2218178975912707E-15]\nperiod_0 = 2.3538670417546639E+00\n\nrvf = [1.1648780946517576,\n    0.0,\n    -1.1145303634437023E-1,\n    0.0,\n    -2.0191923237095796E-1,\n    0.0]\nperiod_f = 3.3031221822879884\n\nWe can now define the objective function\n\nfunction objective(x, u)\n    return sum(u[4,:])\nend\n\nWe will now define the problem parameters\n\nN = 100\nnx = 6\nnu = 4                              # [ux,uy,uz,Γ]\ntf = 2.6 \ntimes = LinRange(0.0, tf, N)\n\nthrust = 0.35    # N\numax = thrust/MU/1e3 / (VU/TU)\n\nWe will now define an initial guess by propagating the initial and final boundary conditions\n\n# initial & final LPO\nsol_lpo0 = solve(\n    ODEProblem(eom!, rv0, [0.0, period_0], params),\n    Tsit5(); reltol = 1e-12, abstol = 1e-12\n)\nsol_lpof = solve(\n    ODEProblem(eom!, rvf, [0.0, period_f], params),\n    Tsit5(); reltol = 1e-12, abstol = 1e-12\n)\n\n# create reference solution\nx_along_lpo0 = sol_lpo0(LinRange(0.0, period_0, N))\nx_along_lpof = sol_lpof(LinRange(0.0, period_f, N))\nx_ref = zeros(nx,N)\nalphas = LinRange(0,1,N)\nfor (i,alpha) in enumerate(alphas)\n    x_ref[:,i] = (1-alpha)*x_along_lpo0[:,i] + alpha*x_along_lpof[:,i]\nend\nu_ref = zeros(nu, N-1)\n\nthen, we instantiate the problem struct\n\nprob = SCPLib.ContinuousProblem(\n    Clarabel.Optimizer,\n    eom!,\n    params,\n    objective,\n    times,\n    x_ref,\n    u_ref;\n    ode_method = Vern7(),\n)\nset_silent(prob.model)              # we will silence the convex program\n\nand we will append convex constraints to prob.model\n\n# append boundary conditions\n@constraint(prob.model, constraint_initial_rv, prob.model[:x][:,1] == rv0)\n@constraint(prob.model, constraint_final_rv,   prob.model[:x][:,end] == rvf)\n\n# append constraints on control magnitude\n@constraint(prob.model, constraint_associate_control[k in 1:N-1],\n    [prob.model[:u][4,k], prob.model[:u][1:3,k]...] in SecondOrderCone())\n@constraint(prob.model, constraint_control_magnitude[k in 1:N-1],\n    prob.model[:u][4,k] <= umax)","category":"section"},{"location":"ocp_basic_cr3bp.html#Instantiate-algorithm-and-solve-problem","page":"Basic OCP","title":"Instantiate algorithm & solve problem","text":"We can now instantiate an algorithm and solve\n\nalgo = SCPLib.SCvxStar(nx, N; w0 = 1e4)\nsolution = SCPLib.solve!(algo, prob, x_ref, u_ref; maxiter = 100)\n\n Solving OCP with SCvx* Algorithm (`・ω・´)\n\n   Feasibility tolerance tol_feas :  1.00e-06\n   Optimality tolerance tol_opt   :  1.00e-04\n   Objective tolerance tol_J0     : -1.00e+16\n   Initial penalty weight w       :  1.00e+04\n   Use L1 penalty                 :  No\n\nIter |     J0     |    ΔJ_i    |    ΔL_i    |     χ_i    |    ρ_i    |    r_i    |     w     |  acpt. |\n   1 | -3.085e-10 |  5.319e+01 |  5.806e+01 |  1.043e-02 |  9.16e-01 |  5.00e-02 |  1.00e+04 |  yes   |\n   2 |  1.727e-11 |  1.980e+01 |  2.430e+01 |  5.612e-03 |  8.15e-01 |  1.50e-01 |  2.00e+04 |  yes   |\n   3 |  2.001e+00 | -6.762e+01 |  2.266e+01 |  2.469e-02 | -2.98e+00 |  4.50e-01 |  4.00e+04 |  no    |\n   4 |  2.001e+00 | -6.762e+01 |  2.266e+01 |  2.469e-02 | -2.98e+00 |  2.25e-01 |  4.00e+04 |  no    |\n   5 |  2.194e+00 |  1.125e+01 |  2.259e+01 |  8.513e-03 |  4.98e-01 |  1.13e-01 |  4.00e+04 |  yes   |\n   6 |  6.712e+00 | -2.341e+01 |  5.402e+01 |  1.198e-02 | -4.33e-01 |  1.13e-01 |  8.00e+04 |  no    |\n   7 |  6.682e+00 |  4.138e+01 |  5.393e+01 |  2.869e-03 |  7.67e-01 |  5.63e-02 |  8.00e+04 |  yes   |\n   8 |  8.502e+00 | -2.967e+02 |  2.179e+01 |  2.114e-02 | -1.36e+01 |  1.69e-01 |  1.60e+05 |  no    |\n   9 |  8.475e+00 | -3.237e+00 |  2.176e+01 |  3.462e-03 | -1.49e-01 |  8.44e-02 |  1.60e+05 |  no    |\n  10 |  8.476e+00 |  2.056e+01 |  2.168e+01 |  2.079e-03 |  9.48e-01 |  4.22e-02 |  1.60e+05 |  yes   |\n  11 |  8.263e+00 | -1.425e+01 |  5.732e+00 |  3.804e-03 | -2.49e+00 |  1.27e-01 |  3.20e+05 |  no    |\n  12 |  8.263e+00 | -1.425e+01 |  5.732e+00 |  3.804e-03 | -2.49e+00 |  6.33e-02 |  3.20e+05 |  no    |\n  13 |  8.268e+00 |  3.471e+00 |  5.719e+00 |  1.496e-03 |  6.07e-01 |  3.16e-02 |  3.20e+05 |  yes   |\n  14 |  8.235e+00 |  1.147e+01 |  1.148e+01 |  5.480e-04 |  9.99e-01 |  3.16e-02 |  6.40e+05 |  yes   |\n  15 |  8.211e+00 |  2.210e+00 |  2.211e+00 |  1.404e-05 |  9.99e-01 |  9.49e-02 |  1.28e+06 |  yes   |\n  16 |  8.211e+00 | -3.579e-02 |  2.356e-03 |  5.955e-05 | -1.52e+01 |  2.85e-01 |  2.56e+06 |  no    |\n  17 |  8.211e+00 | -3.580e-02 |  2.356e-03 |  5.956e-05 | -1.52e+01 |  1.42e-01 |  2.56e+06 |  no    |\n  18 |  8.211e+00 | -3.581e-02 |  2.356e-03 |  5.957e-05 | -1.52e+01 |  7.12e-02 |  2.56e+06 |  no    |\n  19 |  8.211e+00 | -3.581e-02 |  2.356e-03 |  5.956e-05 | -1.52e+01 |  3.56e-02 |  2.56e+06 |  no    |\n\nIter |     J0     |    ΔJ_i    |    ΔL_i    |     χ_i    |    ρ_i    |    r_i    |     w     |  acpt. |\n  20 |  8.211e+00 | -3.580e-02 |  2.356e-03 |  5.955e-05 | -1.52e+01 |  1.78e-02 |  2.56e+06 |  no    |\n  21 |  8.211e+00 | -3.578e-02 |  2.356e-03 |  5.954e-05 | -1.52e+01 |  8.90e-03 |  2.56e+06 |  no    |\n  22 |  8.211e+00 | -2.800e-03 |  2.259e-03 |  1.760e-05 | -1.24e+00 |  4.45e-03 |  2.56e+06 |  no    |\n  23 |  8.212e+00 |  1.682e-03 |  2.056e-03 |  1.853e-06 |  8.18e-01 |  2.22e-03 |  2.56e+06 |  yes   |\n  24 |  8.211e+00 | -5.020e-03 |  3.791e-04 |  1.506e-05 | -1.32e+01 |  6.67e-03 |  5.12e+06 |  no    |\n  25 |  8.211e+00 | -2.623e-03 |  3.759e-04 |  1.058e-05 | -6.98e+00 |  3.34e-03 |  5.12e+06 |  no    |\n  26 |  8.211e+00 |  1.677e-04 |  3.210e-04 |  1.108e-06 |  5.22e-01 |  1.67e-03 |  5.12e+06 |  yes   |\n  27 |  8.211e+00 | -7.971e-05 |  2.599e-04 |  1.616e-06 | -3.07e-01 |  1.67e-03 |  1.02e+07 |  no    |\n  28 |  8.211e+00 |  2.199e-04 |  2.325e-04 |  9.000e-07 |  9.46e-01 |  8.34e-04 |  1.02e+07 |  yes   |\n  29 |  8.211e+00 | -1.211e-03 |  7.310e-05 |  3.910e-06 | -1.66e+01 |  2.50e-03 |  2.05e+07 |  no    |\n  30 |  8.211e+00 | -1.498e-04 |  6.814e-05 |  1.409e-06 | -2.20e+00 |  1.25e-03 |  2.05e+07 |  no    |\n  31 |  8.211e+00 |  4.314e-05 |  5.283e-05 |  6.349e-08 |  8.17e-01 |  6.26e-04 |  2.05e+07 |  yes   |\n\n   Status                   : Optimal\n   Iterations               : 31\n   Total CPU time           : 2.08 sec\n   Objective                : 8.2112e+00\n   Objective improvement ΔJ : 4.3138e-05 (tol: 1.0000e-04)\n   Max constraint violation : 6.3492e-08 (tol: 1.0000e-06)","category":"section"},{"location":"ocp_basic_cr3bp.html#Analyze-solution","page":"Basic OCP","title":"Analyze solution","text":"We can now visualize the solution\n\n# propagate controlled trajectory solution\nsols_opt, g_dynamics_opt = SCPLib.get_trajectory(prob, solution.x, solution.u)\narc_colors = [\n    solution.u[4,i] > 1e-6 ? :red : :black for i in 1:N-1\n]\nfor (i, _sol) in enumerate(sols_opt)\n    lines!(ax3d, Array(_sol)[1,:], Array(_sol)[2,:], Array(_sol)[3,:], color=arc_colors[i])\nend\n\n# plot controls\nax_u = Axis(fig[2,1]; xlabel=\"Time\", ylabel=\"Control\")\nfor i in 1:3\n    stairs!(ax_u, prob.times[1:end-1], solution.u[i,:], label=\"u[$i]\", step=:pre, linewidth=1.0)\nend\nstairs!(ax_u, prob.times[1:end-1], solution.u[4,:], label=\"||u||\", step=:pre, linewidth=2.0, color=:black, linestyle=:dash)\naxislegend(ax_u, position=:cc)\n\n# plot iterate information\ncolors_accept = [solution.info[:accept][i] ? :green : :red for i in 1:length(solution.info[:accept])] \nax_χ = Axis(fig[1,2]; xlabel=\"Iteration\", ylabel=\"χ\", yscale=log10)\nscatterlines!(ax_χ, 1:length(solution.info[:accept]), solution.info[:χ], color=colors_accept, marker=:circle, markersize=7)\n\nax_w = Axis(fig[2,2]; xlabel=\"Iteration\", ylabel=\"w\", yscale=log10)\nscatterlines!(ax_w, 1:length(solution.info[:accept]), solution.info[:w], color=colors_accept, marker=:circle, markersize=7)\n\nax_J = Axis(fig[1,3]; xlabel=\"Iteration\", ylabel=\"ΔJ\", yscale=log10)\nscatterlines!(ax_J, 1:length(solution.info[:accept]), abs.(solution.info[:ΔJ]), color=colors_accept, marker=:circle, markersize=7)\n\nax_Δ = Axis(fig[2,3]; xlabel=\"Iteration\", ylabel=\"trust region radius\", yscale=log10)\nscatterlines!(ax_Δ, 1:length(solution.info[:accept]), [minimum(val) for val in solution.info[:Δ]], color=colors_accept, marker=:circle, markersize=7)\n\ndisplay(fig)\n\n(Image: SCvxStar CR3BP Trajectory Solution)","category":"section"},{"location":"index.html#SCPLib.jl:-Sequential-Convex-Programming-library","page":"Home","title":"SCPLib.jl: Sequential Convex Programming library","text":"We are interested in solving the discretized non-convex optimal control problem (OCP)\n\nbeginaligned\nmin_x u quad phi(x(t_f)u(t_f)t_fy) + int_t_0^t_f mathcalL(x(t)u(t)t) mathrmdt\n mathrmst quad     dotx(t) = f(x(t)u(t)t)\n     x_k+1 = x_k + int_t_k^t_k+1 f(x_k u_k) mathrmdt quad forall k=1ldotsN-1\n     g(xu) = 0\n     h(xu) leq 0\n     x_1 in mathcalX(t_1)  x_N in mathcalX(t_N)\n     x_k in mathcalX(t_k) u_k in mathcalU(t_k) quad forall k=1ldotsN\nendaligned\n\nNote:\n\nA free-final time problem can be cast as the above OCP by including physical time as a state & adopting a time dilation.","category":"section"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"For now, git clone the repo & add via pkg> dev ./path/to/SCPLib.jl.","category":"section"},{"location":"index.html#Illustrative-example","page":"Home","title":"Illustrative example","text":"We first need to define a few things:\n\na mutable struct parameter for the ODE, which includes a vector u (the control vector),\nthe controlled equations of motion eom!, which takes as parameter the aforementioned mutable struct,\n(optionally) the augmented equations of motion which propagates the state together with the STM's Phi_A and Phi_B,\nan objective function, dispatched for both JuMP variables and reals,\nan array of time-stamps corresponding to the discretized nodes, and\ninitial guesses for state & control histories, x_ref and u_ref; if the problem also has other variables y, then we also need initial guess for those, i.e. y_ref.\n\n# 0. define dynamics, define initial reference (i.e. initial guess), etc.\nnx = 6   # state dimension\nnu = 4   # control dimension\nmutable struct MyODEParams\n    p           # ODE Parameters\n    u::Vector   # control vector, length `nu`\nend\n\nparams = MyODEParams(p, zeros(nu))\n\neom! = function (dx, x, params, t)\n    # compute derivative of state \n    ...\nend\n\neom_aug! = function (dx_aug, x_aug, params, t)              # optional\n    # compute derivative of state & Phi_A & Phi_B\n    ...\nend\n\nobjective = function (x, u)\n    # compute objective, must be dispatched for both JuMP variables and reals \n    ...\nend\n\nN = 60                          # number of nodes\ntimes = LinRange(0.0, tf, N)    # time-stamp at nodes\nx_ref = ...                     # initial guess for state history\nu_ref = ...                     # initial guess for control history\n\nNow we can use SCPLib to construct & solve our optimal control problem!\n\n# 1. instantiate problem    \nprob = SCPLib.ContinuousProblem(\n    Clarabel.Optimizer,                 # solver for convex subproblems\n    eom!,\n    params,\n    objective,\n    times,\n    x_ref,\n    u_ref;\n    eom_aug! = eom_aug!,                # optional\n)\n\n# 2. append convex constraints to `prob.model` if any\n@constraint(prob.model, constraint_initial_rv, prob.model[:x][:,1] == rv0)     # initial boundary conditions\n@constraint(prob.model, constraint_final_rv,   prob.model[:x][:,end] == rvf)   # final boundary conditions\n\nset_silent(prob.model)\n\n# 3. instantiate an algorithm; here we use the SCvx* algorithm\nalgo = SCPLib.SCvxStar(nx, N; w0 = 1e4)   # as an example, setting `w0` to a non-default value\n\n# 4. solve problem\nsolution = SCPLib.solve!(algo, prob, x_ref, u_ref; maxiter = 100)","category":"section"},{"location":"examples/example_dionysus.html#Example:-dionysus-transfer","page":"Dionysus problem","title":"Example: dionysus transfer","text":"\"\"\"Sample SCP problem with MEE\"\"\"\n\nusing Base.Threads\nusing Clarabel\nusing GLMakie\nusing JuMP\nusing LinearAlgebra\nusing OrdinaryDiffEq\n\nusing AstrodynamicsCore\n\n@show nthreads()\n\ninclude(joinpath(@__DIR__, \"../src/SCPLib.jl\"))\n\nmutable struct ControlParams\n    μ::Float64\n    c1::Float64\n    c2::Float64\n    u::Vector\n    function ControlParams(μ::Float64, c1::Float64, c2::Float64)\n        new(μ, c1, c2, zeros(4))\n    end\nend\n\nMU_SUN = 132712440018.0\nG0 = 9.8065\nDU = 149.6e6\nVU = sqrt(MU_SUN / DU)          # velocity scale, m/s\nTU = DU / VU                    # time scale, s\nMASS = 4000.0                   # kg\n\nTHRUST = 0.32                    # Newtons\nISP = 3000.0                    # seconds\n\nμ  = MU_SUN / (VU^2 * DU)\nc1 = THRUST/1e3 / (MASS*DU/TU^2)               # canonical max thrust\nc2 = THRUST/1e3 / (ISP*G0/1e3) / (MASS/TU)     # canonical mass flow rate\nparams = ControlParams(μ, c1, c2)\n\nfunction eom_mee!(drvm, rvm, params, t)\n    p,f,g,h,k,L,mass = rvm[1:7]   # unpack state\n    cosL = cos(L)\n    sinL = sin(L)\n    s2 = 1 + h^2 + k^2\n    w = 1 + f*cosL + g*sinL\n    hsinL_kcosL = h*sinL - k*cosL\n    B_mee = sqrt(p/params.μ) * [\n         0    2p/w                0;\n         sinL ((1+w)*cosL + f)/w -g/w*hsinL_kcosL;\n        -cosL ((1+w)*sinL + g)/w  f/w*hsinL_kcosL;\n         0    0                   1/w*s2/2*cosL;\n         0    0                   1/w*s2/2*sinL;\n         0    0                   1/w*hsinL_kcosL;\n    ]\n    D = [0.0, 0.0, 0.0, 0.0, 0.0, sqrt(params.μ/p^3) * (1 + f*cosL + g*sinL)^2]\n    drvm[1:6] = B_mee * (params.c1 / mass) * params.u[1:3] + D\n    drvm[7] = -params.u[4] * params.c2\n    return\nend\n\n# -------------------- boundary conditions -------------------- #\ntof = 3534 * 86400 / TU\nN_rev = 5\n\nR0 = [-3637871.081; 147099798.784; -2261.44] / DU\nV0 = [-30.265097; -0.8486854; 0.0000505] / VU\nRV0 = [R0; V0]\norbit_init = AstrodynamicsCore.Planet(params.μ, 0.0, RV0, \"initial\")\nmee0 = AstrodynamicsCore.rv2mee([R0; V0], params.μ)\n\nM0 = deg2rad(114.4232)\nTA0 = AstrodynamicsCore.ma2ta(M0, 0.542)\nkepf = [2.2, 0.542, deg2rad(13.6), deg2rad(82.2), deg2rad(204.2), TA0]\nRVf0 = AstrodynamicsCore.kep2rv(kepf, params.μ)\norbit_final = AstrodynamicsCore.Planet(params.μ, 0.0, RVf0, \"final\")\nRVf = AstrodynamicsCore.eph(orbit_final, tof + (56284 - 53400)  *86400/TU)\nmeef = AstrodynamicsCore.rv2mee(RVf, params.μ)\nmeef[6] += 2π * N_rev   # append revolutions\n\nx0_ref = [mee0; 1.0]\nxf_ref = [meef; 0.4]\n\n# get initial and final orbits for plotting\ninitial_orbit_rvs = hcat([AstrodynamicsCore.eph(orbit_init, t) for t in LinRange(0.0, orbit_init.period, 100)]...)\nfinal_orbit_rvs = hcat([AstrodynamicsCore.eph(orbit_final, t) for t in LinRange(0.0, orbit_final.period, 100)]...)\n\n# -------------------- define objective -------------------- #\nfunction objective(x, u)\n    return -x[7,end]\nend\n\nng = 6\nfunction g_noncvx(x, u)\n    g = AstrodynamicsCore.mee2rv(x[1:6,end], params.μ) - RVf\n    return g\nend\n\n# -------------------- create problem -------------------- #\nN = 500\nnx = 7                              # [p,f,g,h,k,L,mass]\nnu = 4                              # [ux,uy,uz,Γ]\ntimes = LinRange(0.0, tof, N)\n\n# create reference solution\nx_ref = zeros(nx, N)\nx_ref[1:6,:] = hcat(LinRange.(mee0, meef, N)...)'\nx_ref[7,:] = LinRange(x0_ref[7], xf_ref[7], N)\nu_ref = zeros(nu, N-1)\n\n# instantiate problem object    \nprob = SCPLib.ContinuousProblem(\n    Clarabel.Optimizer,\n    eom_mee!,\n    params,\n    objective,\n    times,\n    x_ref,\n    u_ref;\n    ng = ng,\n    g_noncvx = g_noncvx,\n    ode_ensemble_method = EnsembleThreads(),\n    ode_method = Vern7(),\n)\nset_silent(prob.model)\n\n# append boundary conditions\n@constraint(prob.model, constraint_initial_rv, prob.model[:x][:,1] == x0_ref)\n# @constraint(prob.model, constraint_final_rv,   prob.model[:x][1:6,end] == meef)  # enforced in g_noncvx\n\n# minimum on mass for numerical stability\n@constraint(prob.model, constraint_mass_lb[k in 1:N], prob.model[:x][7,k] >= 0.1)\n@constraint(prob.model, constraint_p_lb[k in 1:N], prob.model[:x][1,k] >= 0.8)\n\n# append constraints on control magnitude\n@constraint(prob.model, constraint_associate_control[k in 1:N-1],\n    [prob.model[:u][4,k], prob.model[:u][1:3,k]...] in SecondOrderCone())\n@constraint(prob.model, constraint_control_magnitude[k in 1:N-1],\n    prob.model[:u][4,k] <= 1.0)\n\nsols_ig, _ = SCPLib.get_trajectory(prob, x_ref, u_ref)\n\n# -------------------- instantiate algorithm -------------------- #\nalgo = SCPLib.SCvxStar(nx, N; ng=ng, w0 = 1e0, Δ0=0.1, w_max=1e20)\n\n# solve problem\nmaxiter = 1000\ntol_feas = 1e-6\ntol_opt = 1e-6\nsolution = SCPLib.solve!(algo, prob, x_ref, u_ref; tol_feas = tol_feas, tol_opt = tol_opt, maxiter = maxiter)\nsols_opt, g_dynamics_opt = SCPLib.get_trajectory(prob, solution.x, solution.u)\n@show -solution.info[:J0][end] * MASS\n\n# -------------------- make plot -------------------- #\nfig = Figure(size=(1200,800); title=\"SCP problem with MEE\")\nax3d = Axis3(fig[1,1:2]; aspect=:data, xlabel=\"x\", ylabel=\"y\", zlabel=\"z\")\nax2d = Axis(fig[1,3]; aspect=DataAspect(), xlabel=\"x\", ylabel=\"y\")\n\nscatter!(ax3d, RV0[1], RV0[2], RV0[3], color=:limegreen, markersize=10)\nscatter!(ax3d, RVf[1], RVf[2], RVf[3], color=:blue, markersize=10)\nlines!(ax3d, initial_orbit_rvs[1,:], initial_orbit_rvs[2,:], initial_orbit_rvs[3,:], color=:limegreen, linewidth=0.8)\nlines!(ax3d, final_orbit_rvs[1,:], final_orbit_rvs[2,:], final_orbit_rvs[3,:], color=:blue, linewidth=0.8)\n\nscatter!(ax2d, RV0[1], RV0[2], color=:limegreen, markersize=10)\nscatter!(ax2d, RVf[1], RVf[2], color=:blue, markersize=10)\nlines!(ax2d, initial_orbit_rvs[1,:], initial_orbit_rvs[2,:], color=:limegreen, linewidth=0.8)\nlines!(ax2d, final_orbit_rvs[1,:], final_orbit_rvs[2,:], color=:blue, linewidth=0.8)\n\n# plot initial guess\nucolor_tol = 1e-2\nfor (isol,sol) in enumerate(sols_ig)\n    rvs = hcat([AstrodynamicsCore.mee2rv(Array(sol)[1:6,i], params.μ) for i in 1:length(sol.t)]...)\n    lines!(ax3d, rvs[1,:], rvs[2,:], rvs[3,:], color=:grey, linewidth=1.0)\n    lines!(ax2d, rvs[1,:], rvs[2,:], color=:grey, linewidth=1.0)\nend\n\n# plot optimal solution\nucolor_tol = 1e-2\nfor (isol,sol) in enumerate(sols_opt)\n    rvs = hcat([AstrodynamicsCore.mee2rv(Array(sol)[1:6,i], params.μ) for i in 1:length(sol.t)]...)\n    lines!(ax3d, rvs[1,:], rvs[2,:], rvs[3,:], color=u_ref[4,isol] > ucolor_tol ? :red : :black, linewidth=1.0)\n    lines!(ax2d, rvs[1,:], rvs[2,:], color=u_ref[4,isol] > ucolor_tol ? :red : :black, linewidth=1.0)\nend\n\naxm = Axis(fig[2,1]; xlabel=\"Time, day\", ylabel=\"Mass\", xticks=0:500:3500)\nfor (isol,sol) in enumerate(sols_opt)\n    lines!(axm, sol.t*TU/86400, Array(sol)[7,:] * MASS, color=:black, linewidth=1.0)\nend\nhlines!(axm, solution.x[7,end]*MASS, color=:black, linewidth=1.0, label=\"mf = $(round(solution.x[7,end] * MASS * 1e4)/1e4) kg\", linestyle=:dash)\naxislegend(axm, position=:cc)\n\naxu = Axis(fig[2,2]; xlabel=\"Time, day\", ylabel=\"Control\", xticks=0:500:3500)\nstairs!(axu, times*TU/86400, [solution.u[1,:]; 0.0]; step=:post, color = :blue, linewidth=0.8)\nstairs!(axu, times*TU/86400, [solution.u[2,:]; 0.0]; step=:post, color = :red, linewidth=0.8)\nstairs!(axu, times*TU/86400, [solution.u[3,:]; 0.0]; step=:post, color = :limegreen, linewidth=0.8)\nstairs!(axu, times*TU/86400, [solution.u[4,:]; 0.0]; step=:post, color = :black, linewidth=0.8, linestyle=:dash)\n\ndisplay(fig)\n\n(Image: SCvxStar quadcoptor trajectory solution)","category":"section"},{"location":"ocp_ncvx.html#OCP-with-non-convex-path-constraints","page":"Non-convex path constraints","title":"OCP with non-convex path constraints","text":"We will now consider an optimal control problem with non-convex path constraints. Here, we will enforce the path constraints at discrete nodes.\n\nusing Clarabel\nusing ForwardDiff\nusing GLMakie\nusing JuMP\nusing LinearAlgebra\nusing OrdinaryDiffEq\n\nusing SCPLib","category":"section"},{"location":"ocp_ncvx.html#Define-dynamics","page":"Non-convex path constraints","title":"Define dynamics","text":"We first initialize the dynamics parameters, a control parameter struct, and the equations of motion\n\n# -------------------- setup problem -------------------- #\n# system parameters\nnx = 6\nnu = 4                              # [ux,uy,uz,Γ]\ng = [-9.81, 0, 0]\nk_D = 0.5\nt_N = 5;                        # s, duration of problem\nm = 0.3;                        # kg, mass of quadrotor\nT_min = 1.0;                    # N, minimum thrust\nT_max = 4.0;                    # N, maximum thrust\ntheta_max = pi/4;               # rad, maximum tilt angle\nN = 50;                         # number of nodes\n\n# initial and final states\nx_initial = [0, 0, 0, 0, 0.5, 0];\nx_final = [0, 10, 0, 0, 0.5, 0];\n\n# obstacle avoidance parameters\nR_obstacle_1 = 1.0              # m, radius of obstacle 1\np_obstacle_1 = [0, 3, 0.45]     # m, position of obstacle 1\nR_obstacle_2 = 1.0              # m, radius of obstacle 2\np_obstacle_2 = [0, 7, -0.45]    # m, position of obstacle 2\n\n# ODE parameters\nmutable struct QuadroptorParams\n    u::Vector\nend\n\nparams = QuadroptorParams(zeros(nu))\n\n# rhs and jacobian expressions for quadrotor dynamics\nfunction quadrotor_dfdx(x, u, p, t)\n    v = x[4:6]\n    v_norm = norm(v)\n    dfdx = [zeros(3,3) I(3);\n            zeros(3,3)  (-k_D * (v_norm * I(3) + (v * v') / v_norm))]\n    return dfdx\nend\n\nfunction quadrotor_dfdu(x, u, p, t)\n    dfdu = [zeros(3,4); 1/m * I(3) zeros(3,1)];\n    return dfdu\nend\n\nfunction quadrotor_rhs!(dx, x, p, t)\n    dx[1:3] = x[4:6]\n    dx[4:6] = -k_D*norm(x[4:6])*x[4:6] + g\n    B = quadrotor_dfdu(x[1:6], p.u, p, t)\n    dx[1:6] += B * p.u\n    return\nend\n\nIn this tutorial, we will also define the dynamics function for propagating the state-transition matrices:\n\nfunction quadroptor_rhs_aug!(dx_aug, x_aug, p, t)\n    quadrotor_rhs!(dx_aug, x_aug, p, t)\n\n    # derivatives of Phi_A, Phi_B\n    A = quadrotor_dfdx(x_aug[1:6], p.u, p, t)\n    B = quadrotor_dfdu(x_aug[1:6], p.u, p, t)\n    dx_aug[7:42] = reshape((A * reshape(x_aug[7:42],6,6)')', 36)\n    dx_aug[nx*(nx+1)+1:nx*(nx+1)+nx*nu] = reshape((A * reshape(x_aug[nx*(nx+1)+1:nx*(nx+1)+nx*nu], (nu,nx))' + B)', nx*nu)\nend","category":"section"},{"location":"ocp_ncvx.html#Define-problem","page":"Non-convex path constraints","title":"Define problem","text":"We can define the objective function\n\nfunction objective(x, u)\n    return sum(u[4,:])\nend\n\nWe will now define the non-convex path constraints\n\nnh = 2 * N    # two obstacles, enforced at each node\nfunction h_noncvx(x,u)\n    h = vcat(\n        [R_obstacle_1 - norm(x[1:3,k] - p_obstacle_1) for k in 1:N],\n        [R_obstacle_2 - norm(x[1:3,k] - p_obstacle_2) for k in 1:N]\n    )\n    return h\nend\n\nWe will define an initial guess, then construct a problem struct\n\n# -------------------- create problem -------------------- #\ntimes = LinRange(0.0, t_N, N)\n\nx_ref = hcat([[el for el in LinRange(x_initial[i], x_final[i], N)] for i in 1:6]...)'\nu_ref = zeros(nu, N-1)\nu_ref[1:3,:] = repeat(-m*g, outer=[1,N-1])\nu_ref[4,:] = norm.(eachcol(u_ref[1:3,:]))\n\n# instantiate problem object    \nprob = SCPLib.ContinuousProblem(\n    Clarabel.Optimizer,\n    quadrotor_rhs!,\n    params,\n    objective,\n    times,\n    x_ref,\n    u_ref;\n    nh = nh,\n    h_noncvx = h_noncvx,\n    eom_aug! = quadroptor_rhs_aug!,   # uncomment to use the user-defined eom_aug!\n    ode_method = Tsit5(),\n)\nset_silent(prob.model)\n\nand we will append convex constraints to prob.model\n\n# append boundary conditions\n@constraint(prob.model, constraint_initial_rv, prob.model[:x][:,1] == x_initial)\n@constraint(prob.model, constraint_final_rv,   prob.model[:x][:,end] == x_final)\n@constraint(prob.model, constraint_initial_u, prob.model[:u][1:3,1] == -m * g)\n@constraint(prob.model, constraint_final_u, prob.model[:u][1:3,end] == -m * g)\n\n# append convex path constraints\n@constraint(prob.model, constraint_x, prob.model[:x][1,:] == 0)\n\n# append constraints on control magnitude\n@constraint(prob.model, constraint_associate_control[k in 1:N-1],\n    [prob.model[:u][4,k], prob.model[:u][1:3,k]...] in SecondOrderCone())\n@constraint(prob.model, constraint_control_magnitude_min[k in 1:N-1],\n    prob.model[:u][4,k] >= T_min)\n@constraint(prob.model, constraint_control_magnitude_max[k in 1:N-1],\n    prob.model[:u][4,k] <= T_max)","category":"section"},{"location":"ocp_ncvx.html#Instantiate-algorithm-and-solve-problem","page":"Non-convex path constraints","title":"Instantiate algorithm & solve problem","text":"We can now instantiate an algorithm and solve\n\nalgo = SCPLib.SCvxStar(nx, N; nh=nh, w0 = 10.0, l1_penalty=true)\n\n# solve problem\ntol_feas = 1e-8\ntol_opt = 1e-6\nsolution = SCPLib.solve!(algo, prob, x_ref, u_ref; tol_opt = tol_opt, tol_feas = tol_feas)\n\n Solving OCP with SCvx* Algorithm (`・ω・´)\n\n   Feasibility tolerance tol_feas :  1.00e-08\n   Optimality tolerance tol_opt   :  1.00e-06\n   Objective tolerance tol_J0     : -1.00e+16\n   Initial penalty weight w       :  1.00e+01\n   Use L1 penalty                 :  Yes\n\nIter |     J0     |    ΔJ_i    |    ΔL_i    |     χ_i    |    ρ_i    |    r_i    |     w     |  acpt. |\n   1 |  1.442e+02 |  9.588e+00 |  8.705e+00 |  4.969e-01 |  1.10e+00 |  5.00e-02 |  1.00e+01 |  yes   |\n   2 |  1.445e+02 |  3.493e+01 |  3.370e+01 |  3.488e-01 |  1.04e+00 |  1.50e-01 |  2.00e+01 |  yes   |\n   3 |  1.460e+02 |  3.967e+01 |  4.452e+01 |  1.945e-01 |  8.91e-01 |  4.50e-01 |  2.00e+01 |  yes   |\n   4 |  1.490e+02 |  1.945e+01 |  3.340e+01 |  8.067e-02 |  5.82e-01 |  1.35e+00 |  2.00e+01 |  yes   |\n   5 |  1.509e+02 |  1.205e+01 |  1.207e+01 |  2.637e-04 |  9.98e-01 |  1.35e+00 |  2.00e+01 |  yes   |\n   6 |  1.509e+02 |  1.969e-02 |  1.969e-02 |  6.529e-09 |  1.00e+00 |  4.05e+00 |  2.00e+01 |  yes   |\n   7 |  1.509e+02 |  6.677e-07 |  6.255e-07 |  1.631e-10 |  1.07e+00 |  1.22e+01 |  4.00e+01 |  yes   |\n\n   Status                   : Optimal\n   Iterations               : 7\n   Total CPU time           : 1.70 sec\n   Objective                : 1.5088e+02\n   Objective improvement ΔJ : 6.6765e-07 (tol: 1.0000e-06)\n   Max constraint violation : 1.6306e-10 (tol: 1.0000e-08)","category":"section"},{"location":"ocp_ncvx.html#Analyze-solution","page":"Non-convex path constraints","title":"Analyze solution","text":"We can now visualize the solution\n\n# propagate solution\nsols_opt, g_dynamics_opt = SCPLib.get_trajectory(prob, solution.x, solution.u)\n\n# get obstacles x[2] & x[3] values for plotting\ncoord_obstacle_1 = R_obstacle_1 * [cos.(LinRange(0, 2*pi, 100)) sin.(LinRange(0, 2*pi, 100))]' .+ p_obstacle_1[2:3]\ncoord_obstacle_2 = R_obstacle_2 * [cos.(LinRange(0, 2*pi, 100)) sin.(LinRange(0, 2*pi, 100))]' .+ p_obstacle_2[2:3]\n\n# plot\nfig = Figure(size=(1200,800))\nax2d = Axis(fig[1,1]; xlabel = \"East, m\", ylabel = \"North, m\", autolimitaspect=1)\nscatter!(ax2d, [x_initial[2]], [x_initial[3]], color=:blue)\nscatter!(ax2d, [x_final[2]], [x_final[3]], color=:green)\nfor (i, _sol) in enumerate(sols_opt)\n    lines!(ax2d, Array(_sol)[2,:], Array(_sol)[3,:], color=:black)\nend\nlines!(ax2d, coord_obstacle_1[1,:], coord_obstacle_1[2,:], color=:red)\nlines!(ax2d, coord_obstacle_2[1,:], coord_obstacle_2[2,:], color=:red)\n\n# plot controls\nax_u = Axis(fig[2,1]; xlabel=\"Time\", ylabel=\"Control\")\nfor i in 1:3\n    stairs!(ax_u, prob.times[1:end-1], solution.u[i,:], label=\"u[$i]\", step=:pre, linewidth=1.0)\nend\nstairs!(ax_u, prob.times[1:end-1], solution.u[4,:], label=\"||u||\", step=:pre, linewidth=2.0, color=:black, linestyle=:dash)\nhlines!(ax_u, [-T_max, T_max], color=:red, linestyle=:dot, label=\"||u|| bounds\")\naxislegend(ax_u, position=:cc)\n\n# plot iterate information\ncolors_accept = [solution.info[:accept][i] ? :green : :red for i in 1:length(solution.info[:accept])] \nax_χ = Axis(fig[1,2]; xlabel=\"Iteration\", ylabel=\"χ\", yscale=log10)\nscatterlines!(ax_χ, 1:length(solution.info[:accept]), solution.info[:χ], color=colors_accept, marker=:circle, markersize=7)\n\nax_w = Axis(fig[2,2]; xlabel=\"Iteration\", ylabel=\"w\", yscale=log10)\nscatterlines!(ax_w, 1:length(solution.info[:accept]), solution.info[:w], color=colors_accept, marker=:circle, markersize=7)\n\nax_J = Axis(fig[1,3]; xlabel=\"Iteration\", ylabel=\"ΔJ\", yscale=log10)\nscatterlines!(ax_J, 1:length(solution.info[:accept]), abs.(solution.info[:ΔJ]), color=colors_accept, marker=:circle, markersize=7)\n\nax_Δ = Axis(fig[2,3]; xlabel=\"Iteration\", ylabel=\"trust region radius\", yscale=log10)\nscatterlines!(ax_Δ, 1:length(solution.info[:accept]), [minimum(val) for val in solution.info[:Δ]], color=colors_accept, marker=:circle, markersize=7)\n\ndisplay(fig)\n\n(Image: SCvxStar quadcoptor trajectory solution)","category":"section"}]
}
